@using Bakr.Shared.Dtos
@using Bakr.Shared.Models
@using System.Net.Http.Headers
@attribute [Authorize(Policy = "AdminPolicy")]
@inject ILogger<FileUpload> Logger
@inject HttpClient Http
@rendermode InteractiveWebAssembly


@inject GenresClient GenresClient
@inject ProductsClient ProductClient


<h3>@title</h3>

@if (genres is null || product is null)
{
    <div class="d-flex justify-content-center">
        <div class="spinner-border m-5" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else
{
    <div class="row">
        <div class="col-md-4">
        </div><EditForm Model="@product" FormName="EditProduct" OnValidSubmit="HandleSubmitAsync" Enhance>
        <DataAnnotationsValidator />
        <ValidationSummary />
        <img src="@compindUrl" alt="@product.Name" style="height: 250px; object-fit: cover;">
        <div class="mb-3">
            <label for="image" class="form-label">Image:</label>
                <CascadingValue Value="this">
                    <FileUpload uploadResult="@uploadResult" shouldRender="@shouldRender" validationMessage="@validationMessage"/>
                </CascadingValue>
            <InputText class="form-control" id="image" @bind-Value="product.Picture" hidden/>
            <ValidationMessage For="() => product.Picture" />
        </div>
        <div class="mb-3">
            <label for="name" class="form-label">Name:</label>
            <InputText class="form-control" id="name" @bind-Value="product.Name" />
            <ValidationMessage For="() => product.Name" />
        </div>
        <div class="mb-3">
            <label for="genre" class="form-label">Genre:</label>
            <InputSelect class="form-select" id="genre" @bind-Value="product.GenreId">
            <option value="">Select a genre</option>
            @foreach (Genre genre in genres)
            {
                <option value="@genre.Id">@genre.Name</option>
            }
            </InputSelect>
            <ValidationMessage For="() => product.GenreId" />
        </div>
        <div class="mb-3">
            <label for="description" class="form-label">Description:</label>
            <InputText class="form-control" id="description" @bind-Value="product.Description" />
            <ValidationMessage For="() => product.Description" />
        </div>
        <div class="mb-3">
            <label for="price" class="form-label">Price:</label>
            <InputNumber class="form-control" id="price" @bind-Value="product.Price" />
            <ValidationMessage For="() => product.Price" />
        </div>
        <div class="mb-3">
            <label for="quantity" class="form-label">Quantity:</label>
            <InputNumber class="form-control" id="Quantity" @bind-Value="product.Quantity" />
            <ValidationMessage For="() => product.Quantity" />
        </div>
            <button type="submit" class="btn btn-primary">Submit</button>
            <a class="btn btn-secondary" role="button" href="/">Cancel</a>
        </EditForm>
    </div>
}

@code {
    [Parameter]
    public int? Id {get; set;}

    private bool shouldRender;

    private string? validationMessage;

    public IBrowserFile? file;

    private UploadResult uploadResult = new();

    [Parameter]
    public string? compindUrl {get; set;}

    [Parameter]
    public ProductDetails? productFromParent {get; set;}

    [SupplyParameterFromForm]
    private ProductDetails? product {get; set;}

    private long maxFileSize = 1024 * 1024 * 1; // 1 mb

    [Parameter]
    public Genre[]? genres {get; set;}

    private bool upload = false;

    [Parameter]
    public required string title {get; set;}

    protected override void OnParametersSet()
    {
        if(product is not null) return;
            product = productFromParent;
    }


    private async Task HandleSubmitAsync() {
        ArgumentNullException.ThrowIfNull(product);
        if(file is not null) {
            product.Picture = await InputFileUpload();
        }
        if(Id is null)
            await ProductClient.AddProductAsync(product);
        else {
            product.Id = Id.Value;
            await ProductClient.UpdateProductAsync(product);
        }
        @* NavigationManager.NavigateTo("/"); *@
    }

    private async Task<string?> InputFileUpload()
    {
        shouldRender = false;
        validationMessage = null;

        string? pic = null;

        using var content = new MultipartFormDataContent();

        try
        {
            // Check if file is an image by MIME type
            if (!file!.ContentType.StartsWith("image/"))
            {
                validationMessage = "Only image files are allowed.";
                throw new ArgumentException("Accept images only");
            }

            var fileContent = new StreamContent(file.OpenReadStream(maxFileSize));

            fileContent.Headers.ContentType =
            new MediaTypeHeaderValue(file.ContentType);

            content.Add(
            content: fileContent,
            name: "\"files\"",
            fileName: file.Name);

            upload = true;
        }
        catch (ArgumentException) {
            @* //Logger.LogInformation("{FileName} is not an allowed image type (Err: 4)", file!.Name); *@
            uploadResult = new UploadResult
            {
                FileName = file!.Name,
                ErrorCode = 4, // Custom error code for invalid file type
                Uploaded = false
            };
        }
        catch (Exception ex)
        {
            Logger.LogInformation(
            "{FileName} not uploaded (Err: 6): {Message}",
            file!.Name, ex.Message);

            uploadResult =
            new()
                {
                    FileName = file.Name,
                    ErrorCode = 6,
                    Uploaded = false
                };
        }

        if (upload)
        {
            var response = await Http.PostAsync("/api/Filesave", content);

            var newUploadResult = await response.Content
            .ReadFromJsonAsync<UploadResult>();

            if (newUploadResult is not null)
            {
                if(response.IsSuccessStatusCode) {
                    pic = newUploadResult.StoredFileName;
                }
                uploadResult = newUploadResult;
            }
        }

        shouldRender = true;
        return pic;
    }

}
